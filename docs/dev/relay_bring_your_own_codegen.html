





<!DOCTYPE html>
<html class="writer-html5" lang="kr" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>당신의 codegen을 TVM에 도입하기 &mdash; tvm 0.8.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/tlcpack_theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/tvm-logo-square.png"/>
  

  
  
  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <script type="text/javascript" src="../_static/js/tlcpack_theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="예제로 TVM 코드베이스 익히기" href="codebase_walkthrough.html" />
    <link rel="prev" title="Relay에 컴파일러 패스 추가하기" href="relay_add_pass.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    
<header class="header">
    <div class="innercontainer">
      <div class="headerInner d-flex justify-content-between align-items-center">
          <div class="headerLogo">
               <a href="https://tvm.apache.org/"><img src=https://tvm.apache.org/assets/images/logo.svg alt="logo"></a>
          </div>

          <div id="headMenu" class="headerNav">
            <button type="button" id="closeHeadMenu" class="navCloseBtn"><img src="../_static/img/close-icon.svg" alt="Close"></button>
             <ul class="nav">
                <li class="nav-item">
                   <a class="nav-link" href=https://tvm.apache.org/community>Community</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://tvm.apache.org/download>Download</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://tvm.apache.org/vta>VTA</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://tvm.apache.org/blog>Blog</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://tvm.apache.org/docs>Docs</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://tvmconf.org>Conference</a>
                </li>
                <li class="nav-item">
                   <a class="nav-link" href=https://github.com/apache/tvm/>Github</a>
                </li>
             </ul>
               <div class="responsivetlcdropdown">
                 <button type="button" class="btn-link">
                   ASF
                 </button>
                 <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                 </ul>
               </div>
          </div>
            <div class="responsiveMenuIcon">
              <button type="button" id="menuBtn" class="btn-menu"><img src="../_static/img/menu-icon.svg" alt="Menu Icon"></button>
            </div>

            <div class="tlcDropdown">
              <div class="dropdown">
                <button type="button" class="btn-link dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  ASF
                </button>
                <div class="dropdown-menu dropdown-menu-right">
                  <ul>
                     <li>
                       <a href=https://apache.org/>Apache Homepage</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/licenses/>License</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/sponsorship.html>Sponsorship</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/security/>Security</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/foundation/thanks.html>Thanks</a>
                     </li>
                     <li>
                       <a href=https://www.apache.org/events/current-event>Events</a>
                     </li>
                  </ul>
                </div>
              </div>
          </div>
       </div>
    </div>
 </header>
 
    <nav data-toggle="wy-nav-shift" class="wy-nav-side fixed">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.8.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">입문</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">설치</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">TVM에 기여하기</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deploy/index.html">구현과 탑재</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="how_to.html">Developer How-To Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="relay_add_op.html">Relay에 연산자 추가하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="relay_add_pass.html">Relay에 컴파일러 패스 추가하기</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">당신의 codegen을 TVM에 도입하기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implement-a-c-codegen">C codegen 구현하기</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implement-codegenc">CodegenC 구현</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implement-csourcecodegen">Implement CSourceCodegen</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register-your-codegen">Register Your Codegen</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implement-a-codegen-for-your-representation">Implement a Codegen for Your Representation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implement-examplejsoncodegen">Implement ExampleJsonCodeGen</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implement-a-customized-runtime">Implement a Customized Runtime</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="codebase_walkthrough.html">예제로 TVM 코드베이스 익히기</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">튜토리얼</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Get Started Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#compile-deep-learning-models">Compile Deep Learning Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#tensor-expression-and-schedules">Tensor Expression and Schedules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#optimize-tensor-operators">Optimize Tensor Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#autotvm-template-based-auto-tuning">AutoTVM : Template-based Auto Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#autoscheduler-template-free-auto-scheduling">AutoScheduler : Template-free Auto Scheduling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#developer-tutorials">Developer Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#topi-tvm-operator-inventory">TOPI: TVM Operator Inventory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html#micro-tvm">Micro TVM</a></li>
</ul>
<p class="caption"><span class="caption-text">참고 자료</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../langref/index.html">언어 레퍼런스</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/python/index.html">파이썬 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/links.html">다른 API 참조를 위한 링크</a></li>
</ul>
<p class="caption"><span class="caption-text">심층 해설</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">디자인과 아키텍쳐</a></li>
</ul>
<p class="caption"><span class="caption-text">기타</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../vta/index.html">VTA: 딥러닝 가속기 스택</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">자주 묻는 질문(FAQ)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">인덱스</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      
      <nav class="wy-nav-top" aria-label="top navigation" data-toggle="wy-nav-top">
        
            <div class="togglemenu">

            </div>
            <div class="nav-content">
              <!-- tvm -->
              Table of content
            </div>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        

          




















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> <span class="br-arrow">></span></li>
        
          <li><a href="how_to.html">Developer How-To Guide</a> <span class="br-arrow">></span></li>
        
      <li>당신의 codegen을 TVM에 도입하기</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/dev/relay_bring_your_own_codegen.rst.txt" rel="nofollow"> <img src="../_static//img/source.svg" alt="viewsource"/></a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bring-your-own-codegen-to-tvm">
<span id="relay-bring-your-own-codegen"></span><h1>당신의 codegen을 TVM에 도입하기<a class="headerlink" href="#bring-your-own-codegen-to-tvm" title="Permalink to this headline">¶</a></h1>
<p>딥러닝의 작업부하를 의식한 하드웨어 장치들이 늘어나면서, 다양한 장치에서 고성능을 달성하기 위해 사용자에게 요구되는 지식도 늘어나고 있습니다. 데이터 과학자들이 새로운 모델을 고안할 때 성능 걱정은 하지 않아도 되도록, 하드웨어 백엔드 공급자들은 자주 사용되는 딥러닝 연산과 함께 MKLDNN이나 cuDNN과 같은 라이브러리를 제공하거나, TensorRT와 같이 사용자로 하여금 그들의 모델을 특정한 방식으로 기술하도록 유도하여 고성능을 달성하는 프레임워크를 제공하곤 합니다. 하지만 새로운 라이브러리나 장치로 일을 하려고 할 때, 사용자들은 여전히 새로운 프로그래밍 인터페이스를 배워야 합니다. 따라서, 통합 프로그래밍 인터페이스에 대한 요구는 나날이 커져가고 있습니다. 이는 1) 모든 사용자와 하드웨어 백엔드 공급자들이 동등한 입장에 서도록 하며, 2) 폭넓게 사용되는 몇몇 연산만 극단적인 고성능으로 처리하되 지원되지 않는 연산은 CPU/GPU와 같은 범용장치로 전가하는 특수한 하드웨어나 라이브러리까지도 대응할 수 있는 유연한 솔루션을 제공하기 위한 것입니다.</p>
<p>이 개발자 가이드에서는, 하드웨어 백엔드 공급자로서의 당신이 얼마나 쉽게 당신의 codegen을 구현하고 그것을 당신의 하드웨어 장치/라이브러리를 지원하기 위한 Relay 백엔드 컴파일러로서 등록할 수 있는지 보일 것입니다. 이 가이드는 당신이 대응해야 하는 그래프 표현들에 기반한 두 종류의 codegen에 대해 다룹니다.</p>
<p><strong>1. C 코드를 생성하고 싶은 경우</strong></p>
<p>당신의 하드웨어가 인텔 CPU를 위한 CBLAS/MKL이나 NVIDIA GPU를 위한 CUBLAS처럼 이미 잘 최적화된 C/C++ 라이브러리를 보유하고 있다면, 잘 찾아왔습니다. 다행스럽게도, C 소스 코드 모듈은 TVM 런타임 모듈과 완전 호환되며, 이는 생성된 코드가 적절한 컴파일 플래그가 설정된 어떠한 C/C++ 컴파일러로도 컴파일 될 수 있다는 의미입니다. 따라서 당신이 해야 할 일은 서브그래프에 대응하는 C 코드를 생성하는 codegen을 구현하고 C 소스 모듈을 TVM 런타임 모듈에 이식하는 것 뿐입니다. 당신의 하드웨어를 위한 C 코드 생성기를 어떻게 구현하면 되는지, 다음 섹션에서 보여 드리겠습니다.</p>
<p><strong>2. 다른 그래프 표현을 생성하고 싶을 경우</strong></p>
<p>당신의 하드웨어는 JSON 등과 같은 다른 형식의 그래프 표현을 요구할 수도 있습니다. 이 경우, 당신은 codegen 뿐 아니라 TVM 런타임이 그래프 표현을 어떻게 실행해야 할지 알려주기 위한 맞춤형 TVM 런타임 모듈도 구현해야 합니다. GPU를 위한 TensorRT 처럼, 당신의 하드웨어에 맞는 그래프 실행 엔진을 이미 보유하고 있다면, 고려해 볼 수 있는 솔루션입니다.</p>
<p>codegen과 런타임 구현을 마친 후, 당신의 고객들로 하여금 그들의 모델을 당신의 맞춤형 태그화 함께 가공(annotate)하도록 유도하여, 활용이 가능하게 해줘야 합니다. 최종 사용자가 직접 특정한 codegen을 가공(annotate)하고 론칭할 수 있도록 돕는 튜토리얼은 <strong>여기(TBA)</strong> 에 있습니다.</p>
<div class="section" id="implement-a-c-codegen">
<h2>C codegen 구현하기<a class="headerlink" href="#implement-a-c-codegen" title="Permalink to this headline">¶</a></h2>
<p>여기서, 사전 구현된 연산자 함수들과 함께 C 코드를 생성하는 codegen을 구현하는 법을 설명하겠습니다. 불필요하게 복잡해지지 않도록, 예제 codegen은 서드파티 라이브러리의 의존성이 없도록 했습니다. 대신 C로 쓰인 매크로 두 개를 구현하겠습니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CSOURCE_BINARY_OP_1D(p_ID_, p_OP_, p_DIM1_)         \</span>
<span class="cp">    extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) { \</span>
<span class="cp">        for (int64_t i = 0; i &lt; p_DIM1_; ++i) {             \</span>
<span class="cp">            out[i] = a[i] p_OP_ b[i];                       \</span>
<span class="cp">        }                                                   \</span>
<span class="cp">    }</span>

<span class="cp">#define CSOURCE_BINARY_OP_2D(p_ID_, p_OP_, p_DIM1_, p_DIM2_)  \</span>
<span class="cp">    extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) {   \</span>
<span class="cp">        for (int64_t i = 0; i &lt; p_DIM1_; ++i) {               \</span>
<span class="cp">            for (int64_t j = 0; j &lt; p_DIM2_; ++j) {           \</span>
<span class="cp">                int64_t k = i * p_DIM2_ + j;                  \</span>
<span class="cp">                out[k] = a[k] p_OP_ b[k];                     \</span>
<span class="cp">            }                                                 \</span>
<span class="cp">        }                                                     \</span>
<span class="cp">    }</span>
</pre></div>
</div>
<p>두 매크로를 이용해 1-D와 2-D 텐서에 대한 이항 연산자를 만들어 낼 수 있습니다. 예컨대, 다음과 같은 서브그래프가 주어졌다고 합시다. 모든 입력은 (10, 10) 모양의 2-D 텐서라고 가정합니다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c_compiler_input0</span>
       <span class="o">|</span>
      <span class="n">add</span> <span class="o">&lt;--</span> <span class="n">c_compiler_input1</span>
       <span class="o">|</span>
    <span class="n">subtract</span> <span class="o">&lt;--</span> <span class="n">c_compiler_input2</span>
       <span class="o">|</span>
    <span class="n">multiply</span> <span class="o">&lt;--</span> <span class="n">c_compiler_input3</span>
       <span class="o">|</span>
      <span class="n">out</span>
</pre></div>
</div>
<p>우리의 목표는 다음과 같이 서브그래프를 실행할 수 있는 컴파일 가능한 코드를 생성하는 것입니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/c_runtime_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/packed_func.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;dlpack/dlpack.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="cp">#define GCC_BINARY_OP_1D(p_ID_, p_OP_, p_DIM1_)           \</span>
<span class="cp">  extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) { \</span>
<span class="cp">    for (int64_t i = 0; i &lt; p_DIM1_; ++i) {               \</span>
<span class="cp">      out[i] = a[i] p_OP_ b[i];                           \</span>
<span class="cp">    }                                                     \</span>
<span class="cp">  }</span>

<span class="cp">#define GCC_BINARY_OP_2D(p_ID_, p_OP_, p_DIM1_, p_DIM2_)  \</span>
<span class="cp">  extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) { \</span>
<span class="cp">    for (int64_t i = 0; i &lt; p_DIM1_; ++i) {               \</span>
<span class="cp">      for (int64_t j = 0; j &lt; p_DIM2_; ++j) {             \</span>
<span class="cp">        int64_t k = i * p_DIM2_ + j;                      \</span>
<span class="cp">        out[k] = a[k] p_OP_ b[k];                         \</span>
<span class="cp">      }                                                   \</span>
<span class="cp">    }                                                     \</span>
<span class="cp">  }</span>

<span class="c1">// Note 1</span>
<span class="n">GCC_BINARY_OP_2D</span><span class="p">(</span><span class="n">gcc_0_0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">GCC_BINARY_OP_2D</span><span class="p">(</span><span class="n">gcc_0_1</span><span class="p">,</span> <span class="o">-</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">GCC_BINARY_OP_2D</span><span class="p">(</span><span class="n">gcc_0_2</span><span class="p">,</span> <span class="o">+</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="c1">// Note 2</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">gcc_0_</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">gcc_input0</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">gcc_input1</span><span class="p">,</span>
                       <span class="kt">float</span><span class="o">*</span> <span class="n">gcc_input2</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">gcc_input3</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">buf_0</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">buf_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
  <span class="n">gcc_0_2</span><span class="p">(</span><span class="n">gcc_input0</span><span class="p">,</span> <span class="n">gcc_input1</span><span class="p">,</span> <span class="n">buf_0</span><span class="p">);</span>
  <span class="n">gcc_0_1</span><span class="p">(</span><span class="n">buf_0</span><span class="p">,</span> <span class="n">gcc_input2</span><span class="p">,</span> <span class="n">buf_1</span><span class="p">);</span>
  <span class="n">gcc_0_0</span><span class="p">(</span><span class="n">buf_1</span><span class="p">,</span> <span class="n">gcc_input3</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">buf_0</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">buf_1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Note 3</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">gcc_0_wrapper</span><span class="p">(</span><span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg2</span><span class="p">,</span>
                             <span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg3</span><span class="p">,</span> <span class="n">DLTensor</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">gcc_0_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg0</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
         <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg3</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
         <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">TVM_DLL_EXPORT_TYPED_FUNC</span><span class="p">(</span><span class="n">gcc_0</span><span class="p">,</span> <span class="n">gcc_0_wrapper</span><span class="p">);</span>
</pre></div>
</div>
<p>위 코드에 표기해 둔 Note들에 주목해 봅시다:</p>
<ul class="simple">
<li><p><strong>Note 1</strong> 은 서브그래프의 세 노드에 대한 함수 구현입니다.</p></li>
<li><p><strong>Note 2</strong> 은 중간 매개 버퍼를 할당하여 서브그래프를 실행하고 각 노드에 대응하는 함수들을 호출하는 함수입니다.</p></li>
<li><p><strong>Note 3</strong> 는 TVM 런타임 호환 래퍼(wrapper)입니다. 이 함수는 입력 텐서의 리스트와 출력 텐서(마지막 인자)를 받아들여, 적절한 데이터 형으로 캐스팅하고, Note 2에 기술된 서브그래프 함수를 불러냅니다. 추가로 <code class="docutils literal notranslate"><span class="pre">TVM_DLL_EXPORT_TYPED_FUNC</span></code> 는, 모든 텐서들을 통합 함수 인자인 <code class="docutils literal notranslate"><span class="pre">TVMArgs</span></code> 로 묶고 이를 인자로 받아들이는 함수 <code class="docutils literal notranslate"><span class="pre">gcc_0</span></code> 를 생성합니다. 결과적으로 TVM 런타임은 부가적인 노력 없이 직접 <code class="docutils literal notranslate"><span class="pre">gcc_0</span></code> 를 호출하여 서브그래프를 실행할 수 있습니다. 위와 같이 생성된 코드로, TVM은 그래프의 나머지 부분들과 같이 컴파일 할 수 있으며, 탑재를 위한 단일 라이브러리를 내보낼 수 있습니다.</p></li>
</ul>
<p>이 섹션의 나머지 부분에서 상기 코드를 생성하기 위한 codegen을 단계별로 구현해 보겠습니다. 당신의 codegen은 <code class="docutils literal notranslate"><span class="pre">src/relay/backend/contrib/&lt;your-codegen-name&gt;/</span></code> 에 위치해야 합니다. 우리 예제에서는, codegen을 &quot;codegen_c&quot; 로 명명하고 <a class="reference external" href="https://github.com/apache/tvm/blob/main/src/relay/backend/contrib/codegen_c/codegen.cc">/src/relay/backend/contrib/codegen_c/</a> 아래에 두기로 하겠습니다. 완성된 구현이 궁금하다면 이 파일을 찾아봐도 좋습니다.</p>
<p>이 파일에서 두 특정 클래스들을 구현해 보겠습니다. 다음은 이들 사이의 관계입니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                     <span class="n">subgraph</span>                                <span class="n">subgraph</span>
<span class="n">TVM</span> <span class="n">backend</span> <span class="o">-----------------------------&gt;</span> <span class="n">CSourceCodegen</span> <span class="o">-------------&gt;</span> <span class="n">CodegenC</span>
       <span class="o">^</span>                                       <span class="o">|</span>    <span class="o">^</span>                       <span class="o">|</span>
       <span class="o">|</span>                                       <span class="o">|</span>    <span class="o">|</span>                       <span class="o">|</span>
       <span class="o">----------------------------------------</span>      <span class="o">------------------------</span>
          <span class="n">generated</span> <span class="n">C</span> <span class="n">source</span> <span class="n">runtime</span> <span class="n">module</span>              <span class="n">generated</span> <span class="n">C</span> <span class="n">code</span>
</pre></div>
</div>
<p>Relay 그래프의 한 함수(서브그래프)가 등록된 컴파일러 태그(이 예제에서는 <code class="docutils literal notranslate"><span class="pre">ccompiler</span></code> )로 주석이 붙어 있다는 것을 TVM 백엔드가 발견하면, TVM 백엔드는 <code class="docutils literal notranslate"><span class="pre">CSourceCodegen</span></code> 를 호출하고 서브그래프를 넘깁니다.  <code class="docutils literal notranslate"><span class="pre">CSourceCodegen</span></code> 의 멤버 함수 <code class="docutils literal notranslate"><span class="pre">CreateCSourceModule</span></code> 는 1) 서브그래프에 대한 C 코드를 생성하고, 2) 생성된 C 코드를 TVM 백엔드가 컴파일하고 탑재할 수 있도록 C 소스 런타임 모듈로 포장합니다. 특히 C 코드 생성은 <code class="docutils literal notranslate"><span class="pre">CodegenC</span></code> 클래스에 대해 투명성을 띄는데, 왜냐하면 CodegenC가 코드 생성 구현을 손쉽게 만드는 다수의 유용한 유틸리티를 제공하기 때문입니다. 이어지는 섹션에서 이 두 클래스들을 상향식으로 구현해 보겠습니다.</p>
<div class="section" id="implement-codegenc">
<h3>CodegenC 구현<a class="headerlink" href="#implement-codegenc" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">src/relay/backend/contrib/codegen_c/codegen.cc</span></code> 에서 우선 <code class="docutils literal notranslate"><span class="pre">tvm.relay.contrib</span></code> 네임 스페이스 하에서 codegen 클래스 스켈레톤을 생성합니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/expr_functor.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/transform.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/type.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/object.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;codegen_c.h&quot;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">tvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">relay</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">contrib</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">CodegenC</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprVisitor</span><span class="p">,</span> <span class="k">public</span> <span class="n">CodegenCBase</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">CodegenC</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">ext_func_id_</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">VisitExpr_</span><span class="p">(</span><span class="k">const</span> <span class="n">VarNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">VisitExpr_</span><span class="p">(</span><span class="k">const</span> <span class="n">CallNode</span><span class="o">*</span> <span class="n">call</span><span class="p">)</span> <span class="k">final</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">JIT</span><span class="p">()</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="cm">/*! \brief The function id that represents a C source function. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ext_func_id_</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="cm">/*! \brief The index of a wrapped C function. */</span>
    <span class="kt">int</span> <span class="n">func_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/*! \brief The index of allocated buffers. */</span>
    <span class="kt">int</span> <span class="n">buf_idx_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/*! \brief The arguments of a C compiler compatible function. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ext_func_args_</span><span class="p">;</span>
    <span class="cm">/*! \brief The statements of a C compiler compatible function. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ext_func_body</span><span class="p">;</span>
    <span class="cm">/*! \brief The declaration statements of a C compiler compatible function. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">func_decl_</span><span class="p">;</span>
    <span class="cm">/*! \brief The declaration statements of buffers. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">buf_decl_</span><span class="p">;</span>
    <span class="cm">/*! \brief The name and index pairs for output. */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">out_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CodegenC</span></code> 클래스는 두 클래스를 상속하는데: <code class="docutils literal notranslate"><span class="pre">ExprVisitor</span></code> 는 서브그래프를 순회하며 필요한 정보를 모으고 <code class="docutils literal notranslate"><span class="pre">gcc_0_</span></code> 와 같은 서브그래프 함수를 생성하는 기능을 제공하고; <code class="docutils literal notranslate"><span class="pre">CodegenCBase</span></code> 는 상기 예제의 <code class="docutils literal notranslate"><span class="pre">gcc_0</span></code> 와 같은 포장 함수를 생성하기 위한 유틸리티와 기능을 제공합니다. 보다시피 codegen 클래스를 작동하게 만드려면 세 함수만 구현하면 됩니다.</p>
<div class="section" id="code-generation-for-operators">
<h4>연산자에 대한 코드 생성<a class="headerlink" href="#code-generation-for-operators" title="Permalink to this headline">¶</a></h4>
<p>먼저 <code class="docutils literal notranslate"><span class="pre">VisitExpr_(const</span> <span class="pre">CallNode*</span> <span class="pre">call)</span></code> 를 구현합니다. 이 함수는 서브그래프를 순회하는 동안 모든 호출 노드를 방문합니다. 각 호출 노드는 당신의 하드웨어에 위임하고 싶은 연산자들을 담고 있습니다. 따라서 위상학적 순위에 따라 그에 상응하는 C 코드를 적합한 연산자들로 생성해야 합니다. 이 함수를 다음과 같이 단계별로 구현해 봅시다.</p>
<p><strong>1. 함수 선언 생성</strong></p>
<p>결과 예시: <code class="docutils literal notranslate"><span class="pre">GCC_BINARY_OP_2D(gcc_0_0,</span> <span class="pre">*,</span> <span class="pre">10,</span> <span class="pre">10);</span></code></p>
<p>함수 선언을 생성하려면, 위와 같이 1) 함수 이름 (e.g., <code class="docutils literal notranslate"><span class="pre">gcc_0_0</span></code>), 2) 연산자 타입(e.g., <code class="docutils literal notranslate"><span class="pre">*</span></code>), 그리고 3) 입력 텐서 모양(e.g., <code class="docutils literal notranslate"><span class="pre">(10,</span> <span class="pre">10)</span></code>). 이 필요합니다. 다행스럽게도, 이러한 정보는 <code class="docutils literal notranslate"><span class="pre">CallNode</span></code> 로부터 쉽게 얻을 수 있습니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">macro_stream</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">decl_stream</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">buf_stream</span><span class="p">;</span>

<span class="c1">// Generate a unique function name you like.</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">func_name</span> <span class="o">=</span> <span class="n">ext_func_id_</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">func_idx</span><span class="o">++</span><span class="p">);</span>

<span class="c1">// Make function declaration string.</span>
<span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CSOURCE_BINARY_OP_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;D(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">func_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>

<span class="c1">// Check the operator type.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IsOp</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;+&quot;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsOp</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="s">&quot;subtract&quot;</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;-&quot;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IsOp</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="s">&quot;multiply&quot;</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*&quot;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unrecognized op&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Extract the input tensor shape.</span>
<span class="k">auto</span> <span class="n">in_shape</span> <span class="o">=</span> <span class="n">GetShape</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">checked_type</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in_shape</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">in_shape</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">macro_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;);&quot;</span><span class="p">;</span>
<span class="n">func_decl_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">macro_stream</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
</pre></div>
</div>
<p>보다시피, 생성된 코드를 클래스 멤버 변수 <code class="docutils literal notranslate"><span class="pre">func_decl_</span></code> 에 푸쉬(push_back) 합니다. 이는 전체 서브그래프를 순회하고 나면 필요한 함수 선언은 모두 수집이 끝나고, 남은 일은 GCC에 의해 컴파일되도록 하는 것 뿐이라는 의미입니다. <code class="docutils literal notranslate"><span class="pre">VisitExpr_(const</span> <span class="pre">CallNode*</span> <span class="pre">call)</span></code> 의 나머지 구현도 이러한 컨셉을 따릅니다.</p>
<p><strong>2. 함수 콜 생성</strong></p>
<p>결과 예시: <code class="docutils literal notranslate"><span class="pre">gcc_0_0(buf_1,</span> <span class="pre">gcc_input3,</span> <span class="pre">out);</span></code></p>
<p>함수 선언 생성 다음에, 적절한 입출력을 갖는 함수 콜을 생성할 필요가 있습니다. 이 함수를 호출할 때 어떤 입력이나 버퍼를 집어넣어야 할지 위해서는 함수의 인자로 주어지는 노드들을 방문해 봐야 합니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">decl_stream</span> <span class="o">&lt;&lt;</span> <span class="n">func_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">VisitExpr</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// Note 1</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">out</span> <span class="p">:</span> <span class="n">out_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">decl_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">decl_stream</span> <span class="o">&lt;&lt;</span> <span class="n">out</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Note 2</span>
</pre></div>
</div>
<p>위 코드에서 Note를 다시 주목해 봅시다.</p>
<p><strong>Note 1</strong>: <code class="docutils literal notranslate"><span class="pre">VisitExpr(call-&gt;args[i])</span></code> 는 현재 함수의 인자 노드를 방문하기 위한 재귀 호출입니다. 인자 노드는 다른 노드의 출력이나 입력 텐서일 수 있습니다. 이 구현 예제에서, 모든 노드는 방문자가 떠나기 전에 클래스 변수 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 를 반드시 업데이트 하도록 합니다. 이를 도시한 그림입니다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">arg_node</span>                 <span class="n">arg_node</span> <span class="o">&lt;-</span> <span class="n">Visit</span> <span class="n">arg</span> <span class="p">(</span><span class="n">Note</span> <span class="mi">1</span><span class="p">)</span>       <span class="n">arg_node</span>
     <span class="o">|</span>                        <span class="o">|</span>                                    <span class="o">|</span>
 <span class="n">curr_node</span> <span class="o">&lt;-</span> <span class="n">Process</span>      <span class="n">curr_node</span>                            <span class="n">curr_node</span> <span class="o">&lt;-</span> <span class="n">Put</span> <span class="s2">&quot;buf_0&quot;</span> <span class="k">as</span> <span class="n">an</span> <span class="nb">input</span> <span class="n">buffer</span>

<span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">out_</span> <span class="o">=</span> <span class="p">{}</span>            <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="n">out_</span> <span class="o">=</span> <span class="p">{}</span>                   <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="n">out_</span> <span class="o">=</span> <span class="p">{(</span><span class="s2">&quot;buf_0&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)}</span>
</pre></div>
</div>
<p>위 그림에서, 클래스 변수 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 는 인자 노드를 방문하기 전에는 비어 있다가, 방문 후에는 <code class="docutils literal notranslate"><span class="pre">arg_node</span></code> 의 출력 버퍼명과 크기로 채워집니다. 인자 노드 방문을 끝마치면, 최종적으로 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 를 살펴봄으로써 어떤 입력 버퍼가 적합한지 알 수 있게 됩니다. 이 섹션의 마지막과 다음 섹션에 걸쳐 우리가 어떻게 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 를 업데이트 하는지 알아보겠습니다.</p>
<p><strong>Note 2</strong>: 이 단계에서 함수 콜 문자열을 닫지 않았다는 것을 알아챘을 것입니다. 이 지점의 함수 콜 문자열은 <code class="docutils literal notranslate"><span class="pre">gcc_0_0(buf_1,</span> <span class="pre">gcc_input3</span></code> 와 같은 꼴입니다. 왜냐하면 이 콜에 대한 마지막 인자(i.e., 출력)을 아직 집어 넣지 못했기 때문입니다. 함수 콜의 출력은 할당된 임시 버퍼나 서브그래프의 출력일 수 있습니다. 이 예제에서는 간단히 모든 콜 노드(다음 단계)를 위한 출력 버퍼를 할당하고 최종적인 버퍼의 결과물을 출력 텐서에 복사하는 걸로 하겠습니다.</p>
<p><strong>3. 출력 버퍼 생성</strong></p>
<p>결과 예시: <code class="docutils literal notranslate"><span class="pre">float*</span> <span class="pre">buf_0</span> <span class="pre">=</span> <span class="pre">(float*)malloc(4</span> <span class="pre">*</span> <span class="pre">100);</span></code></p>
<p>앞 단계에서 언급했듯이, 서브그래프의 입출력 텐서 뿐 아니라, 중간 결과를 보존해 두기 위한 버퍼가 필요할 수 있습니다. 버퍼를 생성하기 위해 버퍼의 타입과 크기를 결정하는 모양 정보를 추출하겠습니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// This example only supports single output.</span>
<span class="k">auto</span> <span class="n">type_node</span> <span class="o">=</span> <span class="n">call</span><span class="o">-&gt;</span><span class="n">checked_type</span><span class="p">().</span><span class="n">as</span><span class="o">&lt;</span><span class="n">TensorTypeNode</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">ICHECK</span><span class="p">(</span><span class="n">type_node</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">runtime</span><span class="o">::</span><span class="n">TypeMatch</span><span class="p">(</span><span class="n">type_node</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">,</span> <span class="n">kDLFloat</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;Only support single output tensor with float type&quot;</span><span class="p">;</span>

<span class="c1">// Generate a unique buffer name.</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">out</span> <span class="o">=</span> <span class="s">&quot;buf_&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">buf_idx_</span><span class="o">++</span><span class="p">);</span>

<span class="c1">// Extract the shape to be the buffer size.</span>
<span class="k">auto</span> <span class="n">out_shape</span> <span class="o">=</span> <span class="n">GetShape</span><span class="p">(</span><span class="n">call</span><span class="o">-&gt;</span><span class="n">checked_type</span><span class="p">());</span>
<span class="kt">int</span> <span class="n">out_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">out_shape</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">out_size</span> <span class="o">*=</span> <span class="n">out_shape</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Make the buffer allocation and push to the buffer declarations.</span>
<span class="n">buf_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;float* &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = (float*)std::malloc(4 * &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">out_size</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;);&quot;</span><span class="p">;</span>
<span class="n">buf_decl_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buf_stream</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
</pre></div>
</div>
<p>출력 버퍼를 할당한 다음, 함수 콜 문자열을 닫을 수 있게 되었습니다. 완성된 함수 콜을 클래스 변수 <code class="docutils literal notranslate"><span class="pre">ext_func_body</span></code> 에 푸쉬(push_back)합니다.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">decl_stream</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;);&quot;</span><span class="p">;</span>
<span class="n">ext_func_body</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">decl_stream</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
</pre></div>
</div>
<p><strong>4. 출력 버퍼 업데이트</strong></p>
<p>현재 콜 노드의 출력을 입력으로 받는 다음 노드로 하여금 어떤 버퍼를 취해야 하는지, 이 방문 함수를 떠나기 전에 클래스 변수 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 를 업데이트 할 필요가 있습니다:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">out_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">out_</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">out</span><span class="p">,</span> <span class="n">out_size</span><span class="p">});</span>
</pre></div>
</div>
<p>축하합니다! 방금 이 클래스의 가장 어려운 함수를 막 끝냈습니다. 다음 두 섹션에서는 이 함수에서 누락되어 있는 몇몇 사소한 부분들을 채워넣을 것입니다.</p>
</div>
<div class="section" id="code-generation-for-input-variables">
<h4>입력 변수를 위한 코드 생성<a class="headerlink" href="#code-generation-for-input-variables" title="Permalink to this headline">¶</a></h4>
<p>콜 노드(이전 섹션의 두번째 단계)의 인자 노드를 방문함으로써 입력 버퍼 정보를 수집했고, 그 인자가 또 다른 콜 노드(네번째 단계)일 경우를 다뤄 보았음을 떠올려 봅시다. 이 섹션에서는 <code class="docutils literal notranslate"><span class="pre">VarNode</span></code> 를 예시로 취하여 다른 노드들을 다루는 방법을 설명하겠습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">VarNode</span></code> 는 모델에서 입력 텐서를 나타냅니다. 이것이 갖는 유일한 중요 정보는 이름 힌트 (e.g., <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">weight</span></code>, 등) 입니다. <code class="docutils literal notranslate"><span class="pre">VarNode</span></code> 에 방문할 때, 이름 힌트를 넘겨줌으로써 후속 콜 노드가 정확한 함수 콜을 생성할 수 있도록, 클래스 변수 <code class="docutils literal notranslate"><span class="pre">out_</span></code> 를 간단히 업데이트합니다.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">VisitExpr_</span><span class="p">(</span><span class="k">const</span> <span class="n">VarNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ext_func_args_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name_hint</span><span class="p">());</span>
  <span class="n">out_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">out_</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name_hint</span><span class="p">(),</span> <span class="mi">0</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>이 예제에서 오프로딩되는 서브그래프는 오직 콜 노드와 변수 노드만 갖는다고 가정한다는 것에 유의하세요. 만일 당신의 서브그래프가 <code class="docutils literal notranslate"><span class="pre">TupleNode</span></code> 처럼 또 다른 타입의 노드를 포함한다면, 거기에도 방문하고 출력 버퍼 정보를 우회해야 할 필요가 있습니다.</p>
</div>
<div class="section" id="code-emitting">
<h4>코드 출력<a class="headerlink" href="#code-emitting" title="Permalink to this headline">¶</a></h4>
<p>이 codegen 클래스의 마지막 부분은 서브그래프를 위한 C 함수를 출력하고 우리가 함수 몸체로서 막 생성한 C 코드를 활용하는 <code class="docutils literal notranslate"><span class="pre">JIT</span></code> 함수입니다. 이전 섹션에서 우리가 생성한 서브그래프 함수에 더해 TVM 런타임이 데이터를 주고 받기 위해 통합 인Remember, in addition to the subgraph function we generated in the previous sections, we also need a wrapper function with a unified argument for TVM runtime to invoke and pass data. Fortunately, the base class we inherited already provides an implementation, <code class="docutils literal notranslate"><span class="pre">JitImpl</span></code>, to generate the function. For example, we can invoke <code class="docutils literal notranslate"><span class="pre">JitImpl</span></code> as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">JitImpl</span><span class="p">(</span><span class="s">&quot;gcc_0&quot;</span> <span class="cm">/* Subgraph symbol (ID) */</span><span class="p">,</span>
        <span class="p">{</span><span class="s">&quot;gcc_input0&quot;</span><span class="p">,</span> <span class="s">&quot;gcc_input1&quot;</span><span class="p">,</span> <span class="s">&quot;gcc_input2&quot;</span><span class="p">,</span> <span class="s">&quot;gcc_input3&quot;</span><span class="p">}</span> <span class="cm">/* Input arguments */</span><span class="p">,</span>
        <span class="p">{</span><span class="s">&quot;float *buf_0 = (float*)malloc(4 * 20)&quot;</span><span class="p">,</span> <span class="p">...}</span> <span class="cm">/* Buffer allocations */</span><span class="p">,</span>
        <span class="p">{</span><span class="s">&quot;gcc_0_2(gcc_input0, gcc_input1, buf_0);&quot;</span><span class="p">}</span> <span class="cm">/* Function body */</span><span class="p">,</span>
        <span class="p">{</span><span class="s">&quot;out&quot;</span><span class="p">}</span> <span class="cm">/* Output */</span><span class="p">);</span>
</pre></div>
</div>
<p>The above call will generate three functions (one from the TVM wrapper macro):</p>
<ol class="arabic simple">
<li><p>The subgraph function <code class="docutils literal notranslate"><span class="pre">gcc_0_</span></code> (with one more underline at the end of the function name) with all C code we generated to execute a subgraph.</p></li>
<li><p>The wrapper function <code class="docutils literal notranslate"><span class="pre">gcc_0__wrapper_</span></code> with a list of <code class="docutils literal notranslate"><span class="pre">DLTensor</span></code> arguments that casts data to the right type and invokes <code class="docutils literal notranslate"><span class="pre">gcc_0_</span></code>.</p></li>
<li><p>The TVM runtime compatible function <code class="docutils literal notranslate"><span class="pre">gcc_0</span></code> with TVM unified function arguments that unpacks TVM packed tensors and invokes <code class="docutils literal notranslate"><span class="pre">gcc_0__wrapper_</span></code>.</p></li>
</ol>
<p>Accordingly, the only thing we need in <code class="docutils literal notranslate"><span class="pre">JIT</span></code> implementation is passing all subgraph function code we generated to <code class="docutils literal notranslate"><span class="pre">JitImpl</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">JIT</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Write function macros</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">decl</span> <span class="p">:</span> <span class="n">func_decl_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="n">decl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">JitImpl</span><span class="p">(</span><span class="n">ext_func_id_</span><span class="p">,</span> <span class="n">ext_func_args_</span><span class="p">,</span> <span class="n">buf_decl_</span><span class="p">,</span> <span class="n">ext_func_body</span><span class="p">,</span> <span class="n">out_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All variables (<code class="docutils literal notranslate"><span class="pre">ext_func_id</span></code>, etc) we passed are class variables and were filled when we traversed the subgraph.</p>
</div>
</div>
<div class="section" id="implement-csourcecodegen">
<h3>Implement CSourceCodegen<a class="headerlink" href="#implement-csourcecodegen" title="Permalink to this headline">¶</a></h3>
<p>Again, let's create a class skeleton and implement the required functions. Note that it inherits <code class="docutils literal notranslate"><span class="pre">CSourceModuleCodegenBase</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CSourceCodegen</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CSourceModuleCodegenBase</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Pass a subgraph function, and generate the C code.</span>
  <span class="kt">void</span> <span class="n">GenCFunc</span><span class="p">(</span><span class="k">const</span> <span class="n">Function</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Use GenCFunc to generate the C code and wrap it as a C source module.</span>
  <span class="n">runtime</span><span class="o">::</span><span class="n">Module</span> <span class="n">CreateCSourceModule</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeRef</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">code_stream_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="implement-gencfunc">
<h4>Implement GenCFunc<a class="headerlink" href="#implement-gencfunc" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">GenCFunc</span></code> simply uses the <code class="docutils literal notranslate"><span class="pre">CodegenC</span></code> we just implemented to traverse a Relay function (subgraph) and obtains the generated C code. The builtin function <code class="docutils literal notranslate"><span class="pre">GetExtSymbol</span></code> retrieves a unique symbol name (e.g., <code class="docutils literal notranslate"><span class="pre">gcc_0</span></code>) in the Relay function and we <strong>must</strong> use it as the C function name, because this symbol is going to be used for DSO runtime lookup.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">GenCFunc</span><span class="p">(</span><span class="k">const</span> <span class="n">Function</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ICHECK</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Input error: expect a Relay function.&quot;</span><span class="p">;</span>

  <span class="c1">// Record the external symbol for runtime lookup.</span>
  <span class="k">auto</span> <span class="n">sid</span> <span class="o">=</span> <span class="n">GetExtSymbol</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>

  <span class="n">CodeGenC</span> <span class="n">builder</span><span class="p">(</span><span class="n">sid</span><span class="p">);</span>
  <span class="n">builder</span><span class="p">.</span><span class="n">VisitExpr</span><span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">body</span><span class="p">);</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="n">builder</span><span class="p">.</span><span class="n">JIT</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="implement-createcsourcemodule">
<h4>Implement CreateCSourceModule<a class="headerlink" href="#implement-createcsourcemodule" title="Permalink to this headline">¶</a></h4>
<p>This function creates a runtime module for the external library. In this example, we create a CSourceModule that can be directly compiled and linked together with a TVM generated DSOModule. After you have implemented <code class="docutils literal notranslate"><span class="pre">CodegenC</span></code>, implementing this function is relatively straightforward:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="o">::</span><span class="n">Module</span> <span class="n">CreateCSourceModule</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeRef</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
  <span class="c1">// Create headers</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;cstdint&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;iostream&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;cstdlib&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;stdio.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;cstring&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;tvm/runtime/c_runtime_api.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;#include &lt;dlpack/dlpack.h&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="c1">// Append some common macro for operator definition.</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">operator_macro</span> <span class="o">=</span> <span class="sa">R</span><span class="s">&quot;</span><span class="dl">op_macro(</span><span class="s"></span>
<span class="s">  #define CSOURCE_BINARY_OP_1D(p_ID_, p_OP_, p_DIM1_)       \</span>
<span class="s">    extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) { \</span>
<span class="s">      for (int64_t i = 0; i &lt; p_DIM1_; ++i) {               \</span>
<span class="s">        out[i] = a[i] p_OP_ b[i];                           \</span>
<span class="s">      }                                                     \</span>
<span class="s">    }</span>

<span class="s">  #define CSOURCE_BINARY_OP_2D(p_ID_, p_OP_, p_DIM1_, p_DIM2_)  \</span>
<span class="s">    extern &quot;C&quot; void p_ID_(float* a, float* b, float* out) {     \</span>
<span class="s">      for (int64_t i = 0; i &lt; p_DIM1_; ++i) {                   \</span>
<span class="s">        for (int64_t j = 0; j &lt; p_DIM2_; ++j) {                 \</span>
<span class="s">          int64_t k = i * p_DIM2_ + j;                          \</span>
<span class="s">          out[k] = a[k] p_OP_ b[k];                             \</span>
<span class="s">        }                                                       \</span>
<span class="s">      }                                                         \</span>
<span class="s">    }</span>
<span class="s">  </span><span class="dl">)op_macro</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">code_stream_</span> <span class="o">&lt;&lt;</span> <span class="n">operator_macro</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="c1">// Generate C code for the subgraph.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">IsInstance</span><span class="o">&lt;</span><span class="n">FunctionNode</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">GenCFunc</span><span class="p">(</span><span class="n">Downcast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">IsInstance</span><span class="o">&lt;</span><span class="n">relay</span><span class="o">::</span><span class="n">ModuleNode</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">relay</span><span class="o">::</span><span class="n">Module</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">Downcast</span><span class="o">&lt;</span><span class="n">relay</span><span class="o">::</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">functions</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">GenCFunc</span><span class="p">(</span><span class="n">Downcast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The input ref is expected to be a Relay function or module&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Create a CSourceModule</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">pf</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">::</span><span class="n">Registry</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;module.csource_module_create&quot;</span><span class="p">);</span>
  <span class="n">ICHECK</span><span class="p">(</span><span class="n">pf</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cannot find csource module to create the external runtime module&quot;</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="n">code_stream_</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="register-your-codegen">
<h3>Register Your Codegen<a class="headerlink" href="#register-your-codegen" title="Permalink to this headline">¶</a></h3>
<p>The last step is registering your codegen to TVM backend. We first implement a simple function to invoke our codegen and generate a runtime module.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="o">::</span><span class="n">Module</span> <span class="n">CCompiler</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeRef</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CSourceCodegen</span> <span class="n">csource</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">csource</span><span class="p">.</span><span class="n">CreateCSourceModule</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we register this function to TVM backend:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s">&quot;relay.ext.ccompiler&quot;</span><span class="p">).</span><span class="n">set_body_typed</span><span class="p">(</span><span class="n">CCompiler</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ccompiler</span></code> is a customized tag to let TVM know this is the codegen it should use to generate and offload subgraphs when the subgraph is annotated with <code class="docutils literal notranslate"><span class="pre">ccompiler</span></code>.</p>
<p>Finally, a good practice is to set up a CMake configuration flag to include your compiler only for your customers. We first create a cmake file: <code class="docutils literal notranslate"><span class="pre">cmake/modules/contrib/CODEGENC.cmake</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">if</span><span class="p">(</span><span class="s">USE_CODEGENC</span><span class="p">)</span>
  <span class="nb">file</span><span class="p">(</span><span class="s">GLOB</span> <span class="s">CSOURCE_RELAY_CONTRIB_SRC</span> <span class="s">src/relay/backend/contrib/codegen_c/codegen.cc</span><span class="p">)</span>
  <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">COMPILER_SRCS</span> <span class="o">${</span><span class="nv">CSOURCE_RELAY_CONTRIB_SRC</span><span class="o">}</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">(</span><span class="s">USE_CODEGENC</span><span class="p">)</span>
</pre></div>
</div>
<p>So that users can configure whether to include your compiler when configuring TVM using <code class="docutils literal notranslate"><span class="pre">config.cmake</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">USE_CODEGENC</span> <span class="s">ON</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implement-a-codegen-for-your-representation">
<h2>Implement a Codegen for Your Representation<a class="headerlink" href="#implement-a-codegen-for-your-representation" title="Permalink to this headline">¶</a></h2>
<p>Although we have demonstrated how to implement a C codegen, your hardware may require other forms of graph representation, such as JSON. In this case, you could modify <code class="docutils literal notranslate"><span class="pre">CodegenC</span></code> class we have implemented to generate your own graph representation and implement a customized runtime module to let TVM runtime know how this graph representation should be executed.</p>
<p>To simplify, we define a graph representation named &quot;ExampleJSON&quot; in this guide. ExampleJSON does not mean the real JSON but just a simple representation for graphs without a control flow. For example, assuming we have the following subgraph named <code class="docutils literal notranslate"><span class="pre">subgraph_0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">input0</span>
   <span class="o">|</span>
  <span class="n">add</span> <span class="o">&lt;--</span> <span class="n">input1</span>
   <span class="o">|</span>
<span class="n">subtract</span> <span class="o">&lt;--</span> <span class="n">input2</span>
   <span class="o">|</span>
<span class="n">multiply</span> <span class="o">&lt;--</span> <span class="n">input3</span>
   <span class="o">|</span>
  <span class="n">out</span>
</pre></div>
</div>
<p>Then the ExampleJON of this subgraph looks like:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>subgraph_0
  input 0 10 10
  input 1 10 10
  input 2 10 10
  input 3 10 10
  add 4 inputs: 0 1 shape: 10 10
  sub 5 inputs: 4 2 shape: 10 10
  mul 6 inputs: 5 3 shape: 10 10
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">input</span></code> keyword declares an input tensor with its ID and shape; while the other statements describes computations in <code class="docutils literal notranslate"><span class="pre">&lt;op&gt;</span> <span class="pre">&lt;output</span> <span class="pre">ID&gt;</span> <span class="pre">inputs:</span> <span class="pre">[input</span> <span class="pre">ID]</span> <span class="pre">shape:</span> <span class="pre">[shape]</span></code> syntax.</p>
<p>In this section, our goal is to implement the following customized TVM runtime module to execute ExampleJSON graphs.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="o">::</span><span class="n">Module</span> <span class="n">ExampleJsonCompiler</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeRef</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ExampleJsonCodeGen</span> <span class="nf">codegen</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">code</span> <span class="o">=</span> <span class="n">codegen</span><span class="p">.</span><span class="n">gen</span><span class="p">();</span> <span class="c1">// Note 1</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">pf</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">::</span><span class="n">Registry</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="s">&quot;module.examplejson_module_create&quot;</span><span class="p">);</span> <span class="c1">// Note 2</span>
    <span class="n">ICHECK</span><span class="p">(</span><span class="n">pf</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cannot find ExampleJson module to create the external runtime module&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s">&quot;relay.ext.examplejsoncompiler&quot;</span><span class="p">).</span><span class="n">set_body_typed</span><span class="p">(</span><span class="n">ExampleJsonCompiler</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Note 1</strong>: We will implement a customized codegen later to generate a ExampleJSON code string by taking a subgraph.</p>
<p><strong>Note 2</strong>: This line obtains a pointer to a function for creating the customized runtime module. You can see that it takes subgraph code in ExampleJSON format we just generated and initializes a runtime module.</p>
<p>In the following sections, we are going to introduce 1) how to implement <code class="docutils literal notranslate"><span class="pre">ExampleJsonCodeGen</span></code> and 2) how to implement and register <code class="docutils literal notranslate"><span class="pre">examplejson_module_create</span></code>.</p>
<div class="section" id="implement-examplejsoncodegen">
<h3>Implement ExampleJsonCodeGen<a class="headerlink" href="#implement-examplejsoncodegen" title="Permalink to this headline">¶</a></h3>
<p>Similar to the C codegen, we also derive <code class="docutils literal notranslate"><span class="pre">ExampleJsonCodeGen</span></code> from <code class="docutils literal notranslate"><span class="pre">ExprVisitor</span></code> to make use of visitor patterns for subgraph traversing. On the other hand, we do not have to inherit <code class="docutils literal notranslate"><span class="pre">CodegenCBase</span></code> because we do not need TVM C++ wrappers. The codegen class is implemented as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/expr_functor.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/transform.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/relay/type.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/object.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">tvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">relay</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">contrib</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">ExampleJsonCodeGen</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprVisitor</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">ExampleJsonCodeGen</span><span class="p">();</span>

    <span class="c1">// Note 1</span>
    <span class="kt">void</span> <span class="nf">VisitExpr_</span><span class="p">(</span><span class="k">const</span> <span class="n">VarNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Skip in this example. */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">VisitExpr_</span><span class="p">(</span><span class="k">const</span> <span class="n">CallNode</span><span class="o">*</span> <span class="n">call</span><span class="p">)</span> <span class="k">final</span> <span class="p">{</span> <span class="cm">/* Skip in this example. */</span> <span class="p">}</span>

    <span class="c1">// Note 2</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">gen</span><span class="p">(</span><span class="n">NodeRef</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">IsInstance</span><span class="o">&lt;</span><span class="n">FunctionNode</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">Downcast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">IsInstance</span><span class="o">&lt;</span><span class="n">relay</span><span class="o">::</span><span class="n">ModuleNode</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">relay</span><span class="o">::</span><span class="n">Module</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">Downcast</span><span class="o">&lt;</span><span class="n">relay</span><span class="o">::</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">mod</span><span class="o">-&gt;</span><span class="n">functions</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="n">Downcast</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The input ref is expected to be a Relay function or module&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="cm">/*! \brief The function id that represents a C source function. */</span>
     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Note 1</strong>: We again implement corresponding visitor functions to generate ExampleJSON code and store it to a class variable <code class="docutils literal notranslate"><span class="pre">code</span></code> (we skip the visitor function implementation in this example as their concepts are basically the same as C codegen). After finished the graph visiting, we should have an ExampleJSON graph in <code class="docutils literal notranslate"><span class="pre">code</span></code>.</p>
<p><strong>Note 2</strong>: We define an internal API <code class="docutils literal notranslate"><span class="pre">gen</span></code> to take a subgraph and generate a ExampleJSON code. This API can be in an arbitrary name you prefer.</p>
<p>The next step is to implement a customized runtime to make use of the output of <code class="docutils literal notranslate"><span class="pre">ExampleJsonCodeGen</span></code>.</p>
</div>
<div class="section" id="implement-a-customized-runtime">
<h3>Implement a Customized Runtime<a class="headerlink" href="#implement-a-customized-runtime" title="Permalink to this headline">¶</a></h3>
<p>In this section, we will implement a customized TVM runtime step-by-step and register it to TVM runtime modules. The customized runtime should be located at <code class="docutils literal notranslate"><span class="pre">src/runtime/contrib/&lt;your-runtime-name&gt;/</span></code>. In our example, we name our runtime &quot;example_ext_runtime&quot;.</p>
<p>Again, we first define a customized runtime class as follows. The class has to be derived from TVM <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> in order to be compatible with other TVM runtime modules.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;dmlc/logging.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/c_runtime_api.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/memory.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/ndarray.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/object.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/packed_func.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tvm/runtime/registry.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">tvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">runtime</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">ExampleJsonModule</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ModuleNode</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">ExampleJsonModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">graph_json</span><span class="p">);</span>

  <span class="n">PackedFunc</span> <span class="nf">GetFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">ObjectPtr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;</span> <span class="n">sptr_to_self</span><span class="p">)</span> <span class="k">final</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">type_key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;examplejson&quot;</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">SaveToBinary</span><span class="p">(</span><span class="n">dmlc</span><span class="o">::</span><span class="n">Stream</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="k">final</span><span class="p">;</span>

  <span class="k">static</span> <span class="n">Module</span> <span class="n">LoadFromBinary</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">strm</span><span class="p">);</span>

  <span class="k">static</span> <span class="n">Module</span> <span class="n">Create</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetSource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">format</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Run</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inputs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">output</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">ParseJson</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">json</span><span class="p">);</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="cm">/* \brief The json string that represents a computational graph. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">graph_json_</span><span class="p">;</span>
  <span class="cm">/* \brief The subgraph that being processed. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">curr_subgraph_</span><span class="p">;</span>
  <span class="cm">/*! \brief A simple graph from subgraph id to node entries. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeEntry</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">graph_</span><span class="p">;</span>
  <span class="cm">/* \brief A simple pool to contain the tensor for each node in the graph. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NDArray</span><span class="o">&gt;</span> <span class="n">data_entry_</span><span class="p">;</span>
  <span class="cm">/* \brief A mapping from node id to op name. */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">op_id_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In particular, there are some functions derived from <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> that we must implement in <code class="docutils literal notranslate"><span class="pre">ExampleJsonModule</span></code>:</p>
<ul class="simple">
<li><p>Constructor: The constructor of this class should accept a subgraph (in your representation), process and store it in any format you like. The saved subgraph could be used by the following two functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetFunction</span></code>: This is the most important function in this class. When TVM runtime wants to execute a subgraph with your compiler tag, TVM runtime invokes this function from your customized runtime module. It provides the function name as well as runtime arguments, and <code class="docutils literal notranslate"><span class="pre">GetFunction</span></code> should return a packed function implementation for TVM runtime to execute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> and <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code>: <code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> serialize the runtime module to a binary format for later deployment. This function will be called by TVM when users use <code class="docutils literal notranslate"><span class="pre">export_library</span></code> API. On the other hand, since we are now using our own graph representation, we have to make sure that <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code> is able to construct the same runtime module by taking the serialized binary generated by <code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetSource</span></code> (optional): If you would like to see the generated ExampleJSON code, you can implement this function to dump it; otherwise you can skip the implementation.</p></li>
</ul>
<p>Other functions and class variables will be introduced along with the implementation of above must-have functions.</p>
<div class="section" id="implement-constructor">
<h4>Implement Constructor<a class="headerlink" href="#implement-constructor" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">explicit</span> <span class="nf">ExampleJsonModule</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">graph_json</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_json_</span> <span class="o">=</span> <span class="n">graph_json</span><span class="p">;</span>
  <span class="n">ParseJson</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_json_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, we implement <code class="docutils literal notranslate"><span class="pre">ParseJson</span></code> to parse a subgraph in ExampleJSON format and construct a graph in memory for later usage. Since we do not support subgraph with branches in this example, we simply use an array to store every nodes in a subgraph in order.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">ParseJson</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">json</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">curr_subgraph</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">json</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss2</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">ss2</span> <span class="o">&gt;&gt;</span> <span class="n">token</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;subgraph_&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">curr_subgraph</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ss2</span> <span class="o">&gt;&gt;</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op_id_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">op_id_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">data_entry_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int64_t</span> <span class="n">total_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">==</span> <span class="s">&quot;input&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int64_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&gt;&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_elements</span> <span class="o">*=</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">shape</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span> <span class="c1">// Note 1</span>
      <span class="kt">bool</span> <span class="n">shape_data</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">NodeEntry</span> <span class="n">entry</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&gt;&gt;</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">==</span> <span class="s">&quot;shape:&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">shape_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">shape_data</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">total_elements</span> <span class="o">*=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoll</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
          <span class="n">shape</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stoll</span><span class="p">(</span><span class="n">token</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">!=</span> <span class="s">&quot;inputs:&quot;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">entry</span><span class="p">.</span><span class="n">inputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">token</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">entry</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
      <span class="n">entry</span><span class="p">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
      <span class="n">graph_</span><span class="p">[</span><span class="n">curr_subgraph</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span> <span class="c1">// Note 2</span>
    <span class="p">}</span>
    <span class="n">DLContext</span> <span class="n">ctx</span><span class="p">;</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">device_type</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DLDeviceType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">ctx</span><span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">data_entry_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">NDArray</span><span class="o">::</span><span class="n">Empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">DLDataType</span><span class="p">{</span><span class="n">kDLFloat</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="n">ctx</span><span class="p">);</span> <span class="c1">// Note 3</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Note 1</strong>: We use a class variable <code class="docutils literal notranslate"><span class="pre">op_id_</span></code> to map from subgraph node ID to the operator name (e.g., <code class="docutils literal notranslate"><span class="pre">add</span></code>) so that we can invoke the corresponding operator function in runtime.</p>
<p><strong>Note 2</strong>: We use a class variable <code class="docutils literal notranslate"><span class="pre">graph_</span></code> to map from subgraph name to an array of nodes. <code class="docutils literal notranslate"><span class="pre">GetFunction</span></code> will query graph nodes by a subgraph ID in runtime.</p>
<p><strong>Note 3</strong>: We use a class variable <cite>data_entry_</cite> to map from a subgraph node ID to a tensor data placeholder. We will put inputs and outputs to the corresponding data entry in runtime.</p>
</div>
<div class="section" id="implement-getfunction">
<h4>Implement GetFunction<a class="headerlink" href="#implement-getfunction" title="Permalink to this headline">¶</a></h4>
<p>After the construction, we should have the above class variables ready. We then implement <code class="docutils literal notranslate"><span class="pre">GetFunction</span></code> to provide executable subgraph functions to TVM runtime:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PackedFunc</span> <span class="nf">GetFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">ObjectPtr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&amp;</span> <span class="n">sptr_to_self</span><span class="p">)</span> <span class="k">final</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">curr_subgraph_</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PackedFunc</span><span class="p">([</span><span class="n">sptr_to_self</span><span class="p">,</span> <span class="k">this</span><span class="p">](</span><span class="n">TVMArgs</span> <span class="n">args</span><span class="p">,</span> <span class="n">TVMRetValue</span><span class="o">*</span> <span class="n">rv</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// Copy input tensors to corresponding data entries.</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ICHECK</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type_code</span><span class="p">()</span> <span class="o">==</span> <span class="n">kNDArrayContainer</span> <span class="o">||</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type_code</span><span class="p">()</span> <span class="o">==</span> <span class="n">kArrayHandle</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;Expect NDArray or DLTensor as inputs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type_code</span><span class="p">()</span> <span class="o">==</span> <span class="n">kArrayHandle</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">data_entry_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">NDArray</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">data_entry_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// Execute the subgraph.</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">it</span> <span class="p">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">curr_subgraph_</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">output</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">ICHECK_GT</span><span class="p">(</span><span class="n">graph_</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">curr_subgraph_</span><span class="p">),</span> <span class="mi">0U</span><span class="p">);</span>

      <span class="c1">// Copy the output from a data entry back to TVM runtime argument.</span>
      <span class="k">auto</span> <span class="n">out_idx</span> <span class="o">=</span> <span class="n">graph_</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">curr_subgraph_</span><span class="p">].</span><span class="n">back</span><span class="p">().</span><span class="n">output</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">type_code</span><span class="p">()</span> <span class="o">==</span> <span class="n">kArrayHandle</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">DLTensor</span><span class="o">*</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">data_entry_</span><span class="p">[</span><span class="n">out_idx</span><span class="p">].</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">NDArray</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">data_entry_</span><span class="p">[</span><span class="n">out_idx</span><span class="p">].</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="o">*</span><span class="n">rv</span> <span class="o">=</span> <span class="n">data_entry_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown subgraph: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PackedFunc</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As can be seen, <code class="docutils literal notranslate"><span class="pre">GetFunction</span></code> is composed of three major parts. The first part copies data from TVM runtime arguments to the corresponding data entries we assigned in the constructor. The second part executes the subgraph with <code class="docutils literal notranslate"><span class="pre">Run</span></code> function (will implement later) and saves the results to another data entry. The third part copies the results from the output data entry back to the corresponding TVM runtime argument for output.</p>
</div>
<div class="section" id="implement-run">
<h4>Implement Run<a class="headerlink" href="#implement-run" title="Permalink to this headline">¶</a></h4>
<p>Now let's implement <code class="docutils literal notranslate"><span class="pre">Run</span></code> function. This function accepts 1) a subgraph ID, 2) a list of input data entry indexs, and 3) an output data entry index.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Run</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inputs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Make a list data entry indexs.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">args</span><span class="p">(</span><span class="n">inputs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">inputs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>

  <span class="c1">// Initialize data holders.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TVMValue</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">type_codes</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Initialize a TVM arg setter with TVMValue and its type code.</span>
  <span class="n">TVMArgsSetter</span> <span class="n">setter</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">type_codes</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

  <span class="c1">// Set each argument to its corresponding data entry.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;add&quot;</span> <span class="o">||</span> <span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;sub&quot;</span> <span class="o">||</span> <span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;mul&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">setter</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data_entry_</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Invoke the corresponding operator function.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;add&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Add</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">type_codes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;sub&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sub</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">type_codes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;mul&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Mul</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">type_codes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown op: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">op_id_</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Run</span></code> function mainly has two parts. The first part allocates a list of <code class="docutils literal notranslate"><span class="pre">TVMValue</span></code>, and maps corresponding data entry blocks. This will become the arguments of our operator functions. The second part than invokes our operator functions. Although we use the same C functions as the previous example, you can replace <code class="docutils literal notranslate"><span class="pre">Add</span></code>, <code class="docutils literal notranslate"><span class="pre">Sub</span></code>, and <code class="docutils literal notranslate"><span class="pre">Mul</span></code> with your own engine. You only need to make sure your engine stores the results to the last argument so that they can be transferred back to TVM runtime.</p>
<p>With above functions implemented, our customized codegen and runtime can now execute subgraphs. The last step is registering an API (<code class="docutils literal notranslate"><span class="pre">examplejson_module_create</span></code>) to create this module:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s">&quot;module.examplejson_module_create&quot;</span><span class="p">)</span>
<span class="p">.</span><span class="n">set_body_typed</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">code</span><span class="p">){</span>
    <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">make_object</span><span class="o">&lt;</span><span class="n">ExampleJsonModule</span><span class="o">&gt;</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">runtime</span><span class="o">::</span><span class="n">Module</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="implement-savetobinary-and-loadfrombinary">
<h4>Implement SaveToBinary and LoadFromBinary<a class="headerlink" href="#implement-savetobinary-and-loadfrombinary" title="Permalink to this headline">¶</a></h4>
<p>So far we have implemented the main features of a customized runtime so that it can be used as other TVM runtimes. However, when users want to save the built runtime to a disk for deployment, TVM has no idea about how to save it. This is the reason we want to implement <code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> and <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code>, which tell TVM how should this customized runtime be persist and restored.</p>
<p>We first implement <code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> function to allow users to save this module in disk.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">SaveToBinary</span><span class="p">(</span><span class="n">dmlc</span><span class="o">::</span><span class="n">Stream</span><span class="o">*</span> <span class="n">stream</span><span class="p">)</span> <span class="k">final</span> <span class="p">{</span>
    <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Write</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">graph_json_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can find that this function is pretty simple. Recall that the only argument we took in constructor is a subgraph representation, meaning that we only need a subgraph representation to construct/recover this customized runtime module. As a result, <code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> simply writes the subgraph to an output DMLC stream. That is, when users use <code class="docutils literal notranslate"><span class="pre">export_library</span></code> API to export the module, the customized module will be an ExampleJSON stream of a subgraph.</p>
<p>Similarity, <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code> reads the subgraph stream and re-constructs the customized runtime module:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">Module</span> <span class="n">LoadFromBinary</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">strm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">dmlc</span><span class="o">::</span><span class="n">Stream</span><span class="o">*</span> <span class="n">stream</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">dmlc</span><span class="o">::</span><span class="n">Stream</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">strm</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">graph_json</span><span class="p">;</span>
  <span class="n">stream</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_json</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">::</span><span class="n">runtime</span><span class="o">::</span><span class="n">make_object</span><span class="o">&lt;</span><span class="n">ExampleJsonModule</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph_json</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">Module</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also need to register this function to enable the corresponding Python API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s">&quot;module.loadbinary_examplejson&quot;</span><span class="p">)</span>
<span class="p">.</span><span class="n">set_body_typed</span><span class="p">(</span><span class="n">ExampleJsonModule</span><span class="o">::</span><span class="n">LoadFromBinary</span><span class="p">);</span>
</pre></div>
</div>
<p>The above registration means when users call <code class="docutils literal notranslate"><span class="pre">tvm.runtime.load_module(lib_path)</span></code> API and the exported library has an ExampleJSON stream, our <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code> will be invoked to create the same customized runtime module.</p>
<p>In addition, if you want to support module creation directly from an ExampleJSON file, you can also implement a simple function and register a Python API as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">Module</span> <span class="n">Create</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">filep</span><span class="p">;</span>
    <span class="n">filep</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">graph_json</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">filep</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">graph_json</span> <span class="o">+=</span> <span class="n">line</span><span class="p">;</span>
        <span class="n">graph_json</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">filep</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">::</span><span class="n">runtime</span><span class="o">::</span><span class="n">make_object</span><span class="o">&lt;</span><span class="n">ExampleJsonModule</span><span class="o">&gt;</span><span class="p">(</span><span class="n">graph_json</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">Module</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TVM_REGISTER_GLOBAL</span><span class="p">(</span><span class="s">&quot;module.loadfile_examplejson&quot;</span><span class="p">)</span>
<span class="p">.</span><span class="n">set_body</span><span class="p">([](</span><span class="n">TVMArgs</span> <span class="n">args</span><span class="p">,</span> <span class="n">TVMRetValue</span><span class="o">*</span> <span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">rv</span> <span class="o">=</span> <span class="n">ExampleJsonModule</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>It means users can manually write/modify an ExampleJSON file, and use Python API <code class="docutils literal notranslate"><span class="pre">tvm.runtime.load_module(&quot;mysubgraph.examplejson&quot;,</span> <span class="pre">&quot;examplejson&quot;)</span></code> to construct a customized module.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In summary, here is a checklist for you to refer:</p>
<ul class="simple">
<li><p>A codegen class derived from <code class="docutils literal notranslate"><span class="pre">ExprVisitor</span></code> and <code class="docutils literal notranslate"><span class="pre">CodegenCBase</span></code> (only for C codegen) with following functions.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">VisitExpr_(const</span> <span class="pre">CallNode*</span> <span class="pre">call)</span></code> to collect call node information.</p></li>
<li><p>Other visitor functions you needed to collect subgraph information.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">JIT</span></code> to generate subgraph code.</p></li>
<li><p>Register codegen.</p></li>
</ul>
</li>
<li><p>A function to create <code class="docutils literal notranslate"><span class="pre">CSourceModule</span></code> (for C codegen).</p></li>
<li><p>A runtime module class derived from <code class="docutils literal notranslate"><span class="pre">ModuleNode</span></code> with following functions (for your graph representation).</p>
<ul>
<li><p>Constructor.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetFunction</span></code> to generate a TVM runtime compatible <code class="docutils literal notranslate"><span class="pre">PackedFunc</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Run</span></code> to execute a subgraph.</p></li>
<li><p>Register a runtime creation API.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SaveToBinary</span></code> and <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code> to serialize/deserialize customized runtime module.</p></li>
<li><p>Register <code class="docutils literal notranslate"><span class="pre">LoadFromBinary</span></code> API to support <code class="docutils literal notranslate"><span class="pre">tvm.runtime.load_module(your_module_lib_path)</span></code>.</p></li>
<li><p>(optional) <code class="docutils literal notranslate"><span class="pre">Create</span></code> to support customized runtime module construction from subgraph file in your representation.</p></li>
</ul>
</li>
<li><p>An annotator to annotate a user Relay program to make use of your compiler and runtime (TBA).</p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          

<footer>

    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="codebase_walkthrough.html" class="btn btn-neutral float-right" title="예제로 TVM 코드베이스 익히기" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="relay_add_pass.html" class="btn btn-neutral float-left" title="Relay에 컴파일러 패스 추가하기" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>

<div id="button" class="backtop"><img src="../_static//img/right.svg" alt="backtop"/> </div>
<section class="footerSec">
    <div class="footerHeader">
      <ul class="d-flex align-md-items-center justify-content-between flex-column flex-md-row">
        <li class="copywrite d-flex align-items-center">
          <h5 id="copy-right-info">© 2020 Apache Software Foundation | All right reserved</h5>
        </li>
      </ul>

    </div>

    <ul>
      <li class="footernote">Copyright © 2020 The Apache Software Foundation. Apache TVM, Apache, the Apache feather, and the Apache TVM project logo are either trademarks or registered trademarks of the Apache Software Foundation.</li>
    </ul>

</section>
</footer>
        </div>
      </div>

    </section>

  </div>
  

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  </body>
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>