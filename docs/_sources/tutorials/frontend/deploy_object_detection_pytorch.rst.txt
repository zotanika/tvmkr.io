
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/frontend/deploy_object_detection_pytorch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_frontend_deploy_object_detection_pytorch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_frontend_deploy_object_detection_pytorch.py:


Compile PyTorch Object Detection Models
=======================================
This article is an introductory tutorial to deploy PyTorch object
detection models with Relay VM.

For us to begin with, PyTorch should be installed.
TorchVision is also required since we will be using it as our model zoo.

A quick solution is to install via pip

.. code-block:: bash

    pip install torch==1.7.0
    pip install torchvision==0.8.1

or please refer to official site
https://pytorch.org/get-started/locally/

PyTorch versions should be backwards compatible but should be used
with the proper TorchVision version.

Currently, TVM supports PyTorch 1.7 and 1.4. Other versions may
be unstable.

.. GENERATED FROM PYTHON SOURCE LINES 42-56

.. code-block:: default


    import tvm
    from tvm import relay
    from tvm import relay
    from tvm.runtime.vm import VirtualMachine
    from tvm.contrib.download import download

    import numpy as np
    import cv2

    # PyTorch imports
    import torch
    import torchvision








.. GENERATED FROM PYTHON SOURCE LINES 57-59

Load pre-trained maskrcnn from torchvision and do tracing
---------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 59-96

.. code-block:: default

    in_size = 300

    input_shape = (1, 3, in_size, in_size)


    def do_trace(model, inp):
        model_trace = torch.jit.trace(model, inp)
        model_trace.eval()
        return model_trace


    def dict_to_tuple(out_dict):
        if "masks" in out_dict.keys():
            return out_dict["boxes"], out_dict["scores"], out_dict["labels"], out_dict["masks"]
        return out_dict["boxes"], out_dict["scores"], out_dict["labels"]


    class TraceWrapper(torch.nn.Module):
        def __init__(self, model):
            super().__init__()
            self.model = model

        def forward(self, inp):
            out = self.model(inp)
            return dict_to_tuple(out[0])


    model_func = torchvision.models.detection.maskrcnn_resnet50_fpn
    model = TraceWrapper(model_func(pretrained=True))

    model.eval()
    inp = torch.Tensor(np.random.uniform(0.0, 250.0, size=(1, 3, in_size, in_size)))

    with torch.no_grad():
        out = model(inp)
        script_module = do_trace(model, inp)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torch/tensor.py:593: RuntimeWarning: Iterating over a tensor might cause the trace to be incorrect. Passing a tensor of different shape won't change the number of iterations executed (and might lead to errors or silently give incorrect results).
      'incorrect results).', category=RuntimeWarning)
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torch/nn/functional.py:3123: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      dtype=torch.float32)).float())) for i in range(dim)]
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torchvision/models/detection/anchor_utils.py:147: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      torch.tensor(image_size[1] // g[1], dtype=torch.int64, device=device)] for g in grid_sizes]
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torchvision/ops/boxes.py:128: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_x = torch.min(boxes_x, torch.tensor(width, dtype=boxes.dtype, device=boxes.device))
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torchvision/ops/boxes.py:130: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_y = torch.min(boxes_y, torch.tensor(height, dtype=boxes.dtype, device=boxes.device))
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torchvision/models/detection/transform.py:271: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for s, s_orig in zip(new_size, original_size)
    /home/sunchul/workspace/gitproj/tvmdoc.multilingual.io/venv/lib/python3.7/site-packages/torchvision/models/detection/roi_heads.py:372: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      return torch.tensor(M + 2 * padding).to(torch.float32) / torch.tensor(M).to(torch.float32)




.. GENERATED FROM PYTHON SOURCE LINES 97-99

Download a test image and pre-process
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 99-111

.. code-block:: default

    img_path = "test_street_small.jpg"
    img_url = (
        "https://raw.githubusercontent.com/dmlc/web-data/" "master/gluoncv/detection/street_small.jpg"
    )
    download(img_url, img_path)

    img = cv2.imread(img_path).astype("float32")
    img = cv2.resize(img, (in_size, in_size))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = np.transpose(img / 255.0, [2, 0, 1])
    img = np.expand_dims(img, axis=0)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Downloading from url https://raw.githubusercontent.com/dmlc/web-data/master/gluoncv/detection/street_small.jpg to test_street_small.jpg
    ...6%, 0.01 MB, 11 KB/s, 0 seconds passed    ...13%, 0.02 MB, 23 KB/s, 0 seconds passed    ...20%, 0.02 MB, 35 KB/s, 0 seconds passed    ...27%, 0.03 MB, 46 KB/s, 0 seconds passed    ...34%, 0.04 MB, 58 KB/s, 0 seconds passed    ...41%, 0.05 MB, 70 KB/s, 0 seconds passed    ...48%, 0.05 MB, 80 KB/s, 0 seconds passed    ...54%, 0.06 MB, 91 KB/s, 0 seconds passed    ...61%, 0.07 MB, 96 KB/s, 0 seconds passed    ...68%, 0.08 MB, 106 KB/s, 0 seconds passed    ...75%, 0.09 MB, 115 KB/s, 0 seconds passed    ...82%, 0.09 MB, 123 KB/s, 0 seconds passed    ...89%, 0.10 MB, 130 KB/s, 0 seconds passed    ...96%, 0.11 MB, 136 KB/s, 0 seconds passed    ...100%, 0.12 MB, 145 KB/s, 0 seconds passed




.. GENERATED FROM PYTHON SOURCE LINES 112-114

Import the graph to Relay
-------------------------

.. GENERATED FROM PYTHON SOURCE LINES 114-118

.. code-block:: default

    input_name = "input0"
    shape_list = [(input_name, input_shape)]
    mod, params = relay.frontend.from_pytorch(script_module, shape_list)








.. GENERATED FROM PYTHON SOURCE LINES 119-125

Compile with Relay VM
---------------------
Note: Currently only CPU target is supported. For x86 target, it is
highly recommended to build TVM with Intel MKL and Intel OpenMP to get
best performance, due to the existence of large dense operator in
torchvision rcnn models.

.. GENERATED FROM PYTHON SOURCE LINES 125-134

.. code-block:: default


    # Add "-libs=mkl" to get best performance on x86 target.
    # For x86 machine supports AVX512, the complete target is
    # "llvm -mcpu=skylake-avx512 -libs=mkl"
    target = "llvm"

    with tvm.transform.PassContext(opt_level=3, disabled_pass=["FoldScaleAxis"]):
        vm_exec = relay.vm.compile(mod, target=target, params=params)








.. GENERATED FROM PYTHON SOURCE LINES 135-137

Inference with Relay VM
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 137-142

.. code-block:: default

    ctx = tvm.cpu()
    vm = VirtualMachine(vm_exec, ctx)
    vm.set_input("main", **{input_name: img})
    tvm_res = vm.run()








.. GENERATED FROM PYTHON SOURCE LINES 143-145

Get boxes with score larger than 0.9
------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 145-155

.. code-block:: default

    score_threshold = 0.9
    boxes = tvm_res[0].asnumpy().tolist()
    valid_boxes = []
    for i, score in enumerate(tvm_res[1].asnumpy().tolist()):
        if score > score_threshold:
            valid_boxes.append(boxes[i])
        else:
            break

    print("Get {} valid boxes".format(len(valid_boxes)))




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Get 9 valid boxes





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  18.987 seconds)


.. _sphx_glr_download_tutorials_frontend_deploy_object_detection_pytorch.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: deploy_object_detection_pytorch.py <deploy_object_detection_pytorch.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: deploy_object_detection_pytorch.ipynb <deploy_object_detection_pytorch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
